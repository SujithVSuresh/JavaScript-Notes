NODEJS is a javascript runtime built on googles v8 engine.
Node js is single threaded, event driven and non blocking.to execute a program written in js
node js is a runtime environment for executing js outsode of browser
Node js is a run-time environment includes everything you nedd 
--------------------------------------
We can run js code in terminal using REPL.
REPL - Read, Eval, Print, Loop

Read - Read user input
Eval - Evaluate user input
Print - Print or Ouput the result
Loop  - Return and wait for new input.

A REPL (Read-Eval-Print Loop) is a tool that allows you to interact with a programming language by typing commands and immediately seeing the results. It reads your input, evaluates it, prints the result, and then waits for your next input. It provides an interactive and iterative way to test and experiment with code without the need to create a full program or script.

----------------------------------------
INPUT FROM USER
--------------

To input from the user we can use readline module.
To import a module from the user we can use require(''). That require will return an object.
const readline = require('readline')

const readline = require('readline');
const rl = readline.createInterface({
    //it will define from where it has to enter the input.
    input: process.stdin,
    output: process.stdout
})

rl.question("Enter your name: ", (name) => {
    console.log("You entered: "+name);
    rl.close();
})

//to listen to an event
rl.on('close', () => {
    console.log("Interface closed")
    process.exit(0);
})


-------------------------------------------

Architectur of nodejs
---------------------
node has several dependencies on which it depends on to work properly.
The most important dependencies are V8 engine and LIBUV.
V8 engine is responsooble for executing js code. it converts js code into machine code.
v8 alone can't create node so that we have LIBUV. iT is a opensource libreary responsoble for dealing with asynchronous input and output.
From browser we cannot use js to read or write files from clients machine because of security reasons.But with node js we have that capability and it is provided by libuv.It gives node access to computing OS, file system, networking etc...

LIBUV also implements two important features of node js, 
-Event loop - is responsible for executing easy tasks like executing callback function and network i/o
-Thread pool - is used to do heavy tasks like file access, compression etc...


Other dependencis of node:
HTTP Parser - 
C-ARES - for dns requests
OPENSSL - for cryptography.
ZLIB - for compression.

--------

What is a process?
A process is a what facilitates the execution of a program. A process is just a program which is currently executing.

What is thread?
Thread is in a process, and a thread is what is responsible for executing a program code in the process.By default, every process has one main thread.

---------

> All normal code executes in main thread.
> All asynchronous code executes in thread pool.
> Once the job of the asynchronous code is complete by staying in the threadpool, the call back function in the asynchronous code will be pushed to the event loop. In the event loop the callback function willl wait for its execution. And when the main thread is empty, the callbackk function will be executed. When the main thread is empty the event loop will push the callback function to the main thread where that callback function get executed.
Event loop pushes the callback function from the callback queue to the main thread weher that callbackfunction get executed.

> A thread pool has 4 main htreads.
----------------------------------------------
Event LOop
----------

-Event loop is where alll the callback function wait for thior execution.
-Event loop offloads a casllback function which is doing heavy task like file reading, conpression, to the thread in the thread pool.
And each thread in thread pool has the purpose of doing different tasks.
NODEjs uses event  driven architecture and it is build around callback function.
----------------------------------------------
- Single threaded web server(non-blocking asynchronous i/o)
- Multithreaded web server(blocking synhronous i/o)


----------------------------------------------

Module
------
In node there are built in module or we can create our own modules.

Accessing build-in module in node:

const os = require("os");
console.log(os.type())
console.log(os.platform())

----
To export a module in a file:
const car = {
    brand: "Suzuki",
    model: "E2"
}
module.exports = car;

To access exported file in another file:
const car = require("./index.js")
-----
Another way to export a module in a file:
const car = {
    brand: "Suzuki",
    model: "E2"
}
exports.car = car;
This will exports the property of an object it points to.
Output: { car: { brand: 'Suzuki', model: 'E2' } }

-----------------------------------------------
Node package manager(NPM)
-------------------------

It allows us too install different packages in our node application.
It is a command line interface for managing packages and a package reposatory from where we can install and manage packages.
npm cli is a software that we use to install and manage third party packages. 

-> npm init
npm init is a command in Node.js and npm (Node Package Manager) that is used to initialize a new Node.js project. When you run npm init in the command line, it prompts you with a series of questions to gather information about your project, and then it generates a package.json file based on your responses. The package.json file is a crucial configuration file for Node.js projects, and it contains metadata about the project as well as a list of dependencies.

-> npm init -y
When you run npm init -y, the -y flag stands for "yes" or "assumeyes," and it is used to automatically accept all default values during the initialization process without prompting you for input. This is useful when you want to quickly set up a new Node.js project with default configurations and accept the standard settings provided by npm without having to manually answer each question.

-> node_modules folder - 
In a Node.js project, the node_modules folder is a directory that typically contains all the third-party libraries and dependencies that your project relies on. When you use npm (Node Package Manager) to install packages or modules for your project, these packages are downloaded and stored in the node_modules folder.

-> To instal a package:
npm install packageName 
or
npm i packageName

-> -save / --save-dev
While installing a package, we can use -save / --save-dev flags. With npm 5.0.0 and later, you can install packages without explicitly using --save or --save-dev. npm automatically determines whether a package is a runtime or development dependency based on the context in which it is installed.

--save to add a package as a runtime dependency and list it in the dependencies section of package.json. It is required at runtime.

--save-dev to add a package as a development dependency and list it in the devDependencies section of package.json. devDependencies are the modules which are only required during development.

Note: if we do not specify any flage then it will be added defaultly to the deoendencies seciton of package.json files.

Types of dependencies
---------------------
-Regular dependencies: A package is called as a simple or regular dependencies if the working of our application or the code which we are writing depends on that package.
eg: express package
-Development dependencies: A package is called as development dependencies, if that package is only required for the development purpose and on which, the working of our application does not depend.
eg: nodemon package.

Types of package installs
-------------------------
Local install: The package is only available in that project folder, where the package is installed. It cannot be used  outside of the folder.
Global install: The package is installed globally in the machine and can be accessed from any folder or any project directory.
-----------------------------------------------
NPM Script
-----------

We normally write 'node filename' to run a js file. But we can do the same thing using npm scripts.
We can specify the commands in package.json file.
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "execute": "node index.js",
    "watch": "node index.js",
    "start": "node index.js"
  },
  'npm run execute' will execute the index.js file
  'npm start' will execute the index.js file
  
> Types of NPM packages
  There are two types of packages in node:
  - local packages and global packages
  
  Local packagea are installed locally on our project and it is only accessible only from our project.
  eg: npm install express
   Global packages are installed globally on your system, making them accessible from any directory.
   eg: npm install -g nodemon

-------------------------------------------------
NPX
----

NPX stands for Node Package eXecute. It is simply an NPM package runner. It allows developers to execute any Javascript Package available on the NPM registry without even installing it. NPX is installed automatically with NPM version 5.2.

package.js
----------
The package.json file is a crucial configuration file in Node.js projects. It serves as a manifest for your project, providing metadata about the project, its dependencies, scripts, and other important details.

------------------------------------------------
Package versions
----------------
"version": "1.0.0"

X.Y.Z

x -> Major version
Y -> Minor version
Z -> Patch version

-----
> "node": "<=6.0.0" - will accept all versions greater than or equal to 6.0.0

> "node": "<=6.0.0" - will accept all versions less than or equal to ...

> "webpack": "^5.90.3" - this will accept all changes in patch and minor release.

> "package-name": "~1.2.3" - this will update only the patch release, not the minor and major release.

If you specify an exact version (e.g., "package-name": "1.2.3") in your package.json, npm will install that exact version.
To update, you need to manually change the version in your package.json file and run npm install again.

npm update
This command updates all packages to the latest versions based on the version constraints specified in your package.json. It respects semantic versioning (SemVer) rules, ensuring that minor and patch updates are applied while avoiding major updates that might introduce breaking changes.


Uninstalling packages
---------------------

To remove from devDependencies use -D
npm uninstall -D uuid

To remove from dependencies use -S
npm uninstall -S uuid

We can also use -D and -S for installing package as well.

To remove packages that are installed globally
npm uninstall -g uuid

--------------------------------------------------------

HTTP Server
-----------

Inorder to build web serverss in nodejs we need to do two things:
Step1: CREATE A SERVER
Step2: START THE SERVER

const http = require('http');

//Step1: CREATE A SERVER
const server = http.createServer((request, response) => {
    // this callback function get executed everytime a new request hits the server.
    console.log(response);
    
    //to send response to the client.
    response.end("Hello from the server");
})

//Step2: START THE SERVER
server.listen(8000, '127.0.0.1', ()=>{
    console.log("Server has started")
})

We cant send any request until the server is not running.
hostname = '127.0.0.1'
port = 8000
--------------------------------------------------------------
How Web Works
-------------
1. DOmain name is resolved from the DNS
2. TCP/IP connection has been made b/w the client and the server.
3. Send http request and receive http responsive.

HTTP request contain some information related to that request.
Request contain:
- Request type.(GET, POST, PUT, DELETE)
- Resource we are trying to access(eg: /Home)
- Http version(HTTP/1.1)
- Request header.(It contain information like browser name, accept-language, and many nore info...)
- Body


HTTP response contain some information related to that response.
Response contain:
- Status code.
- Response header.(Contain information about the response which the server is sending back.)
  We can also create our own custom header and send it with response.
- Body(Some content like html file).
  If the html page is using css or js file then the browser will make another request to download the css or js file. 
  
  
>> TCP/IP is the communication protocol that define how data travel across the web.

-------------------------------------------------------------

How request and response works
-------------------------------const http = require('http');
const fs = require('fs');

const html = fs.readFileSync('./templates/hello.html', 'utf-8')

//Step1: CREATE A SERVER
const server = http.createServer((request, response) => {
    // this callback function get executed everytime a new request hits the server.
    console.log(response);
    
    //to send response to the client.
    response.end(html);
})

//Step2: START THE SERVER
server.listen(8000, '127.0.0.1', ()=>{
    console.log("Server has started")
})

We can also send html file as response using fs module.
Network sectioon in developer tool will have all the request and response information.
-----------------------------------------------------------------

What is routing?
-----------------
Routing defines the way in which the client requests are handled by application endpoint.
By implementing routing we can make our application respond to different urls.

Different types of URL:
1. File based URL - in this url the filename will be specified that we want to see in the browser.
   eg: www.nodeapp.com/about.html
2. Resource based URL
   eg: www.nodeapp.com/Home
   Here the resource based url is Home. Based on the resource name the backenfd application will send us the corresponding file.
   
3. Route Parameter
   www.nodeapp.com/Product/101
   Here Product is the resource and 101 is the parameter. 
   
4. Query String
   www.nodeapp.com/Book?author=john&id=101
   Query string is a key value pair. We write the query string after a ?
   
Using routing we can extract, query string, resourse and parameter from the url.   
   
------------------------------------------------------------------
> To get url resource :- 
let path = request.url;

Routing using if statement
//Step1: CREATE A SERVER
const server = http.createServer((request, response) => {
    let path = request.url;
    if(path === '/' || path.toLocaleLowerCase() == '/home'){
        response.end("You are in home page");
    }else if(path.toLocaleLowerCase() == '/about'){
        response.end("You are in about page");
    }else if(path.toLocaleLowerCase() == '/contact'){
        response.end("You are in contact page");
    }else{
        response.end("Error 404: Page not found");
    }
})
----------------------------------------------------------------

Sending HTML response based on routes
-------------------------------------

const server = http.createServer((request, response) => {
    let path = request.url;
    if(path === '/' || path.toLocaleLowerCase() == '/home'){
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN HOME PAGE'));
    }else if(path.toLocaleLowerCase() == '/about'){
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN ABOUT PAGE'));
    }else if(path.toLocaleLowerCase() == '/contact'){
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN CONTACT PAGE'));
    }else{
        response.end(html.replace('{{%CONTENT%}}', 'Error 404: Page not found!'));
    }
})

index.html
<body>
    <a href="Home">Home</a>
    <a href="Products">Products</a>
    <a href="About">About</a>
    <a href="Contact">Contact</a>
    <h3>{{%CONTENT%}}</h3>    
</body>
------------------------------------------------------------------

Setting headers for response
----------------------------

Setting header using header.writeHeader()

//Step1: CREATE A SERVER
const server = http.createServer((request, response) => {
    let path = request.url;
    if(path === '/' || path.toLocaleLowerCase() == '/home'){
        response.writeHead(200, {
            //Content type tells what kind of content we are sending as response
            'Content-Type' : 'text/html',
            //We can also send custom data as header reesponse
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN HOME PAGE'));
    }else if(path.toLocaleLowerCase() == '/about'){
        response.writeHead(200, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN ABOUT PAGE'));
    }else if(path.toLocaleLowerCase() == '/contact'){
        response.writeHead(200, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN CONTACT PAGE'));
    }else{
        response.writeHead(404, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'Error 404: Page not found!'));
    }
})
------------------------------------------------------------------
Working with JSON data
----------------------
The only diffreence between json data and js object is that, in json data the keys should be wrapped inside "".

We can transform the json data to a js object and then we can display that js object in our html page.

const http = require('http');
const fs = require('fs');

const html = fs.readFileSync('./templates/hello.html', 'utf-8')
let products = JSON.parse(fs.readFileSync('./Data/products.json', 'utf-8'))
let productListHtml = fs.readFileSync('./templates/product-list.html', 'utf-8')


let productHtmlArray = products.map((prod) => {
    let output = productListHtml.replace('{{%ID%}}', prod.id)
    output = output.replace('{{%NAME%}}', prod.name)
    output = output.replace('{{%AGE%}}', prod.age)
    output = output.replace('{{%EMAIL%}}', prod.email)
    output = output.replace('{{%CITY%}}', prod.city)

    return output;
}) 

//Step1: CREATE A SERVER
const server = http.createServer((request, response) => {
    let path = request.url;
    if(path === '/' || path.toLocaleLowerCase() == '/home'){
        response.writeHead(200, {
            //Content type tells what kind of content we are sending as response
            'Content-Type' : 'text/html',
            //We can also send custom data as header reesponse
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', productListHtml));
    }else if(path.toLocaleLowerCase() == '/about'){
        response.writeHead(200, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        respoconsoleer.nse.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN ABOUT PAGE'));
    }else if(path.toLocaleLowerCase() == '/contact'){
        response.writeHead(200, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'YOU ARE IN CONTACT PAGE'));
    }else if(path.toLocaleLowerCase() == '/products'){
        let productResponseHtml = html.replace('{{%CONTENT%}}', productHtmlArray.join(","))
        response.writeHead(200, {
            'Content-Type': 'text/html'
        });
        response.end(productResponseHtml);
    }else{
        response.writeHead(404, {
            'Content-Type' : 'text/html',
            'my-header': "Hello world"
        })
        response.end(html.replace('{{%CONTENT%}}', 'Error 404: Page not found!'));
    }
})

------------------------------------------------------------------
Parsing query strig from URL
----------------------------

url package - we can use url package to parse the string.
const url = require('url');

This url object has a method parse() 
parse() accept a url as first parameter and boolean value as second parameter. So we can pass request.url to parse(). As the second argument, if we specify tru, then it will parse the query string else it will not parse the query string.
const x = url.parse(request.url, true)
The above x will return an object:
Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: '?id=2&name=iphone',
  query: [Object: null prototype] { id: '2', name: 'iphone' },
  pathname: '/Products',
  path: '/Products?id=2&name=iphone',
  href: '/Products?id=2&name=iphone'
}

-------------------------------------------------------------------

Module
------
A module is another script file from where we can export some values and that values can be used in another script file by simply importing it.

There are 3 types of modules:
-Core modules (eg: readline, fs, http, url)
-User defined modules
-Third party modules or libraries

> This is how we export a function in a file:
module.exports = function(template, prod){

    return output;
}

-------------------------------------------------------------------
Event driven architecture
--------------------------
Event driven architecture has three main players:
- Event emitter -> Event emitter emits an event when something important happens, eg: the request hitting the server, timer expiring, file finishes reading,  
- Event listener -> When an event is emitted or raised, it is pickedup by event listener
- Event Handler -> This event listeener fires up the callback function attached to that event listener, when that event happens.That function is called as event handlers.

Most of the nodejs features such as http, filesystem and timer are all build on top of event drivrn architecture.

> Event driven architecture to create server:

//event emitter
const server = http.createServer(); 

server.listen(8000, '127.0.0.1', ()=>{
    console.log('listening to requests.....');
})

//event listener
server.on('request', (req, res)=>{
    res.end('Hello from server!');
})
//The above callback function is the event handler function.

#This event emitting and listening logic is known as observer pattern in js programming.
The idea is that the event listener keeps observing the subjects that the listener is waiting for.
subject here is the event emitter.

---------------------------------------------------------------------
Emitting and Handling Custom events
-----------------------------------
To create custom events we have to use events module.
const events = require('events');

let myEmitter = new events.EventEmitter() //here we created the instance of the event emitter class

//This is event listener
myEmitter.on('userCreated', ()=>{
    console.log('a new user is created')
})

myEmitter.emit('userCreated');//This will emit an event called userCreated

>> We can create multiple event listeners for same event.
-----------------------------------------
myEmitter.on('userCreated', ()=>{
    console.log('a new user is created')
})

myEmitter.on('userCreated', ()=>{
    console.log('A new user is created in the DB')
})


>> To pass arguments to the event listener
------------------------------------------

myEmitter.on('userCreated', (id, name)=>{
    console.log(`a new user ${name} with ${id} is created`)
})

myEmitter.on('userCreated', (id, name)=>{
    console.log(`a new user ${name} with ${id} is added to DB`)
})

myEmitter.emit('userCreated', 102, 'Sujith');//This will emit an event called userCreated
-----------------------------------------------------------------------

ExpressJS
---------

const express = require('express')

const app = express(); //we call the express class and initialise it to the app variable

//routes
app.get("/ping", (req, res)=>{
    res.send("Node express application");
})

//for starting a server.
//It will listen for the server to start at port 3000 and consolea message.
app.listen(3000, () => {
    console.log("Server started on port 3000");
})

-----

//This middleware will add all this routers inside this server
app.use('/route', router)
// => /route is the name of the router. We use /route/login to access it.

//home route
app.get('/', (req, res)=>{

    if(req.session.user){
        res.render('dashboard', {user: req.session.user})
    }else{
    res.render('base', {title: "Login System"}) 
    }
    
})

app.listen(port, () => {
    console.log("Listening to the server on http://localhost:3000")
})
> nodemon

nodemon is a tool used in the development of Node.js applications. It is a utility that monitors for changes in your Node.js application and automatically restarts the server when any changes are detected. This eliminates the need to manually stop and restart the server every time you make a change to your code, which can greatly improve development workflow efficiency.

- We installed nodemon module  
- Added "start": "nodemon server.js" to scripts in package.json file

-----
> Middleware

Middleware functions are functions which has access to the request and response object.
Middleware functions can do 3 major things:
    - making changes to request and response object.
    - end request and response cycle
    - call next middleware in a stack. next()

const express = require('express')

const app = express(); //we call the express class and initialise it to the app variable

//middleware function
const myLogger = function(req, res, next){
    console.log("Logged");
    next();
}
const requestTime = function(req, res, next){
    req.reqTime = Date.now();
    next()
}

//load middleware function
app.use(myLogger)
app.use(requestTime)

app.get('/', function(req, res){
    res.send(`Current Time: ${req.reqTime}`)
})

app.listen(3000, ()=>{
    console.log("App started on port 3000")
})

When we specify use() method to use the middleware then the node will put the middleware function in a middleware callstack.
next() will tell the middleware callstack to move to the next middleware.

-----
> Serving static files in express
---------------------------------
To use the static function in our application, we can use the middleware function for that.

app.use(express.static('public')) // This will tell the server to use the static files in the public folder.

- If we use this middleware function, then we can access the static function from the root directory like:
<img src="/img_girl.jpg">

- How do we serve the staticfile if the public folder structure is like:
  public/images/photo.png
        /css/a.css
        /JS/a.js
        
  To so;ve that issue, we can pass an argument to the use method:
  app.use('/public', express.static('static'))      
  Here we are specifying the path to the public folder in root directory as first argument. Then we are specifying the folder inside the public folder inside the express.static() method.

- What if we change the static folder name and root folder name. In that case we need to change the hard coded value. so to solve that problem we can use path module.

#Virtual path prefix#
const path = require('path');
const publicpath = path.resolve(__dirname, "public") //__dirname is the root directory.
app.use(publicpath, express.static('public'))

Now to call static method using virtual path we have to use, 
<img src="public/img_girl.jpg">
-----

Routing in Express
------------------

const express = require('express');
const app = express();

const PORT = 3000;

const data = {
    id: 1,
    name: "India",
    state: "Kerala"
}

app.get("/", (req, res) => {
    res.end("Welcome to my homepage");
})

//Can send any type of data
app.get("/about", (req, res) => {
    res.send("Welcome to my about page.");
})

//To send json data
app.get("/weather", (req, res) => {
    res.json(data);
})

//To send file
app.get("/weatherone", (req, res) => {
    res.sendFile("/static/index.html");
})

app.listen(PORT, ()=>{
    console.log("Server is started on PORT", PORT)
})

There are many more response method than this.

-----

Working with views in express
-----------------------------
To create dynamic html, we have different view engines. There are different template engine that we csn use with expreess to create dynamic html. eg:Pug, EJS, Handlebars etc..

We have to install pug to use pug in our nodejs application.


view directory - is the default directory where our template files are situated. This is the default directory of template engine.

Code:

server.js
---------
const express = require('express');
const app = express();

const PORT = 3000;

//setting the pug template engine
app.set('view engine', 'pug')

app.get('/', (req, res) => {
    res.render("index", {title: "Sujith's Express View Engine", h1:"Express Application", p:"Express Template Engine"})
}).listen(PORT, () => {console.log("Server started on http://localhost:3000")})

index.pug
---------
doctype html 
html
  title=title
  body
    h1=h1
    p=p

---------------------------------------------
Core express(Submitting form data)
------------

server.js
--------
const express = require("express")
const path = require("path")
const app = express()

const PORT = process.env.PORT || 3000

//initialising pug template engine
app.set('view engine', 'pug')

//To seriaalize the form data. This is a middleware method and we are passing a middleware to serialize the data
app.use(express.urlencoded({
    extended:true
}))

app.get('/', (req, res) => {
    res.render("index", {title:"Form Handling"})
})

app.post('/form_submit', (req, res) => {
    const username = req.body.username
    const email = req.body.email
    res.end(`Your Username is ${username} and Email is ${email}`)
})

app.listen(PORT, ()=>{
    console.log(`Listening to requests on http://localhost:${PORT}`)
})


index.pug
---------
doctype html 
html
  title #{title}
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  
  body 
    div.text-center
      h1.h1.py-4 Simple Form
    div.container.text-center.w-25 
      form(method='POST', action='/form_submit')
        div.form-group
          input(type='text', name='username', class='form-control', value="", placeholder="Username")
        div.form-group
          input(type='text', name='email', class='form-control', value="", placeholder="Email")
        div.form-group
          input(type='submit', class='btn btn-primary', value="Submit")  


Whenever submitting a form data we have to serialize that form data using an inbuilt middleware:
app.use(express.urlencoded({
    extended:true
}))

-----------------------------------------------
Session
-------
Session are used to track the user activity.

To use session in express applicstion, we need to install a module called express-session

Setup session using middleware method in express
app.use(session({
    secret:"Your Secret Key",
    resave:true,
    saveUninitialized:true
}))

Add data to session
app.get("/", (req, res) => {
    req.session.name="Sujith";
    return res.send("Session set")
})

Show data to session
app.get("/session", (req, res) => {
    var name = req.session.name;
    return res.send(name)
})

Destroy data in a session
app.get("/destroy", (req, res) => {
    req.session.destroy((error)=>{
        console.log("Session Destroyed")
    })
    res.end();
})

server.js
---------
const express = require("express")
const app = express()
const session = require("express-session")

const PORT = process.env.PORT || 3000

app.use(session({
    secret:"Your Secret Key",
    resave:true,
    saveUninitialized:true
}))

app.get("/", (req, res) => {
    req.session.name="Sujith";
    return res.send("Session set")
})

app.get("/session", (req, res) => {
    var name = req.session.name;
    return res.send(name)
})

app.get("/destroy", (req, res) => {
    req.session.destroy((error)=>{
        console.log("Session Destroyed")
    })
    res.end();
})

app.listen(PORT, ()=>{
    console.log(`Listening to requests on http://localhost:${PORT}`)
})
-------------------------------------------------
Cookies
-------
cookies are small data that are stored in client side and send to the client along with server request

To work with cookies we need to work with a module named cookie-parser


const cookies = require("cookie-parser")
app.use(cookies());

Setting cookie:
app.get("/setuser", (req, res) => {
    //res.cookie() is a method used to set cookies in the response. 
    res.cookie("userData", users)
    res.send("User data added to cookies")
})


Reading cookie data:
app.get("/getuser", (req, res)=>{
    res.send(req.cookies);
})

Destroying cookie data:
app.get("/logout", (req, res) => {
    res.clearCookie('userData')
    res.send("User logout successfully")
})



server.js
---------
const express = require("express")
const app = express()
const cookies = require("cookie-parser")

const PORT = process.env.PORT || 3000

//initialising cookie-parser module
app.use(cookies());

let users = {
    name: "John",
    age: 22
}

app.get("/", (req, res)=>{
    res.send("Cookies tutorial")
})

app.get("/setuser", (req, res) => {
    //res.cookie() is a method used to set cookies in the response. 
    res.cookie("userData", users)
    res.send("User data added to cookies")
})

app.get("/getuser", (req, res)=>{
    res.send(req.cookies);
})

app.get("/logout", (req, res) => {
    res.clearCookie('userData')
    res.send("User logout successfully")
})

app.listen(PORT, ()=>{
    console.log(`Listening to requests on http://localhost:${PORT}`)
})

-----------------------------------------------------
Creating Login Page
--------------------

Modules Installed:-

> ejs 
> express-session 
> body-parser
> uuid

Separation of Concerns (SoC) is a software design principle that advocates for dividing a computer program into distinct sections, each addressing a separate concern. 

>> body-parser - this module is used to parse the incoming request body in the middleware before we use it.

const bodyparser = require("body-parser")

//serializing form data
app.use(bodyparser.json())
app.use(bodyparser.urlencoded({extended:true}))

There are other ways to add serialization.

-------------------------------------------------------

Read and write files synchronously
----------------------------------

Reading file:-
--------------

let textIn = fs.readFileSync('./files/input.txt', 'utf-8')

This will read the file and and return the content. And that content will be stored in textIn variable.

readFileSync() - read file synchronously means the next action will only happens after completely reading the file. There are asynchronous method to do the same task.

Writing file:-
--------------

let content = `Data read from input.txt: ${textIn}. \nDate created ${new Date()}`
fs.writeFileSync('./files/output.txt', content);


Here the first parameter is file path and second parameter is content we can to write to the file.
This will write content to that file. Even if that file is not present, node will reate that file inthe file path and write the content to that file.

-----

const fs = require('fs');

// ./ - current directory.
let textIn = fs.readFileSync('./files/input.txt', 'utf-8')
console.log(textIn)

let content = `Data read from input.txt: ${textIn}. \nDate created ${new Date()}`
fs.writeFileSync('./files/output.txt', content);



--------------------------------------------------------

Read and write files asynchronously
----------------------------------- 


-> Reading file
----------------

const fs = require('fs');

fs.readFile('./files/start.txt', 'utf-8', (error, data)=>{
    console.log(data)
    fs.readFile(`./files/${data}.txt`, 'utf-8', (error2, data2) => {
        console.log(data2)
    })
})
console.log('Reading file......')

Here at 'first reading file...' will be executed first, then the first readFile method wil be executed and then the second readFile method will be executed.


-> Writing file
---------------
fs.writeFile('./files/output.txt', `${data2}\n\n${data3}\n\n${new Date()}`, ()=>{
                console.log("File written successfully...!!!")
            })
            
-----

const fs = require('fs');

fs.readFile('./files/start.txt', 'utf-8', (error, data)=>{
    console.log(data)
    fs.readFile(`./files/${data}.txt`, 'utf-8', (error2, data2) => {
        console.log(data2)
        fs.readFile('./files/append.txt', 'utf-8', (error3, data3) => {
            console.log(data3)
            fs.writeFile('./files/output.txt', `${data2}\n\n${data3}\n\n${new Date()}`, ()=>{
                console.log("File written successfully...!!!")
            })
        })
    })
})
console.log('Reading file......')

This is the full code of reading and writing file.
-------------------------------------------------------------

Streams
-------

If we want to read a file, we use readFile method. When we use a readFile method to read a file, a buffer is created. From the source file the content id read at the read buffer, allthe content is available for us to read.

If we want to write the data in the data variable to another file, we need to use writeFile method.
A buffer is creeated and all the data is written in the buffer and from the buffer all the data is written to the destination file. All this happens at once.


- With streams we can process data piece by piece instead of reading or writing the whole data at once. We are reading a chunk of data, storing it in the memory, and we are using it and then we are freeing the memory. This process is repeated until whole the file is processed.

Advantage
---------
- Streaaming makes the data processing more efficient in terms of memory.Because there is no need to keep all the data in the memory.
- In terms of performance and time also, streaming has its advantage becausr we can start processing the data as soon as the first chunk of data arrives.

Types of streams:
-----------------
- Readable Stream
  The readable streams are the one from where we can read or consume data chunk by chunk.
  
  Eg: 
  - Request stream: When we send a request to a server a readable stream is opened. Through that readable stream we get the request data in chunks.
  - Read file stream: We can read a file piece by piecce by using the createReadStream from the fs module.
  
  Important readable stream event:
  data & end
  data event is emitted when there is new piece or new chunk of data to consume.
  end event is emitted as soon as there is no more data to consume.
  
  Important readable stream methods:
  read & pipe
  
- Writable Stream: The writable streams are the one to which we can write data chunk by chunk. Its opposite of readable stream.

  Eg:
  Response stream
  Write file stream
  
  Important readable stream events:
  drain & finish
  
  Important readable stream methods:
  write and end

- Duplex Stream 
  Duplex stream is a simply a stream that is both readable and writable at the same time.
  eg: Web socket

- Transform Stream
  Transform streams are duplex streams which can also modify or transform data as it is read or write.
  Eg: zlib(to compress data)

----------------------------------------------------------

Understanding streams in practice
---------------------------------

server.on('request', (req, res) => {
    fs.readFile('./files/large-file.txt', (err, data) => {
        res.end(data)
    })
})

We can read files using this method.But the problem is the node here has to load the entire data into the memory.

To solve this we have to use readable and writable stream:-

server.on('request', (req, res) => {
    let rs = fs.createReadStream('./files/large-file.txt');
    
    rs.on('data', (chunk) => {
        res.write(chunk)
        res.end();
    })

    
})

When this readable stream starts reading data from that file then it is going to read that data in chunks. Everytime it reads new chunk of data it is going to emit a data event. So to take that event we used, 
rs.on('data', (chunk) => {
        res.write(chunk)
        res.end();
    })

res.end() tells that everything has finished writing and nothing left to write and it will close the response stream.

One benefit is that, whenever a new piece of data is fetched, only that piece of data is only stored in the memory. And then it will be send inthe response. And once we have send in the response that data in the emory will be removed.

Another benifits is user here do not have to wait until the full data is rend as response. Once a iece of data is send fetched then that will be send to the user as response.

-----
const http = require('http')
const fs = require('fs')

const server = http.createServer();



server.listen(3000, '127.0.0.1', () => {
    console.log('Server has started');
})

server.on('request', (req, res) => {
    let rs = fs.createReadStream('./files/large-file.txt');
    
    rs.on('data', (chunk) => {
        res.write(chunk)
    })
    
    //saying we have no more data to write in the response stream
    rs.on('end', ()=>{
        res.end()
    })
    
    //handling error
    rs.on('error', (error) => {
        res.end(error.message);
    })  
})
-----
-----------------------------------------------------------
pipe()
------
The above method has a problem.
If Our readable stream is reading the data at 4mbps and our writable stream is writing the data at 3 mbps. So here our readable stream is little faster than our writable stream and this will overwhelm our writable stream and it cannot handle all this incoming data so fast. This is known as back pressure.
To solve this problem we can use pipe method.

Back pressure in streams refers to a condition where the rate of flow of data in a stream is being impeded or slowed down due to various factors. This term is commonly used in the context of computer science, especially in software systems dealing with streams of data, such as network communication, file I/O, or data processing pipelines. 


server.on('request', (req, res) => {
    let rs = fs.createReadStream('./files/large-file.txt');
    //pipe method is only available in readable stream
    //pipe method allows us to pipe the output of a readable stream to the input of a writable stream
    //in our case our writable stream is res.
    rs.pipe(res)
})

syntax: readableSource.pipe(writableDestination)

---------------------------------------------------------------
Route parameters
----------------


app.get('/api/products/:id', (req, res) => {
    console.log(req.params)
    res.send(req.params)
})

'/api/products/:id' - this is how we specify the route for route parameters.
req.params - this is how we take that route parameter.
---------------------------------------------------------------
param middleware
----------------

const express = require('express');
const app = express();

// Param middleware to validate ID parameter
app.param('id', (req, res, next, value) => {
  if (!/^\d+$/.test(value)) {
    return res.status(400).send('Invalid ID format');
  }
  next(); // Proceed if valid
});


Param middleware allows you to execute code only when a specific route parameter is present in the URL of an Express application. This provides a targeted way to handle logic related to dynamic route segments in your URLs.

---------------------------------------------------------------
Chaining of middleware
----------------------

router.route('/')
    .post(moviesController.validateBody, moviesController.addMovie)

//chaining of middlewares. Here this middleware will be executed in the order in which it is defined here

//Here the first middleware in post method is for validation and the second parameter is for adding movie data.

---------------------------------------------------------------



























